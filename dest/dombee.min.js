var Dombee=function(){"use strict";function e(e,t){const n="function"==typeof e?e.toString():e;return Object.keys(t).filter(e=>n.match(new RegExp("\\b"+e+"\\b")))}function t(e,t){const n=Object.keys(t);return Function(...n,"return "+e+";")}function n(e,t){const n=Object.keys(t);return Function(...n,"return `"+e+"`;")}function o(e=""){return e+Math.random().toString(36).substring(2,15)}const r=function(){function r(e={}){const t={bindings:{},dependencies:{}},n=new Proxy(e,{set(e,o,r){e[o]=r,f(e,o,r);for(let r of t.dependencies[o])f(e,r,n[r]);return!0},get:(e,t)=>e[t]});function s(e="",t){const n=l(),o=Object.keys(n).map(e=>n[e]);return("string"==typeof e?i(e,t):e)(...o)}function i(e,t){const n=l("parsable");for(let o of t)try{const t=r.globalCache.expressionTypes[o];if(null==t)throw`Expressiontype "${o}" does not exist. If the name is correct, please add it with "Dombee.addExpressionType('${o}', function(text,values){/*your code here*/})"`;return t(e,n)}catch(e){if("string"==typeof e)throw new Error(e)}throw new Error(`Expression ${e} can not be parsed.`)}function a(e,s,a,c={}){const d=e.expression?e.expression.toString():e.toString(),l=r.globalCache.dependencyEvaluationStrategy(d,n),u=function(e){return e&&e.expressionTypes?Array.isArray(e.expressionTypes)?e.expressionTypes:[e.expressionTypes]:r.globalCache.defaultExpressionTypes}(c);for(let n of l)if(t.dependencies[n]||(t.dependencies[n]=[]),n!==s){const r=a?a+"_"+o(""):s;t.dependencies[n].push(r),t.bindings[r]={elemid:a,name:s,onChange:c.onChange,resultFn:i(e.expression?e.expression:e,u),resultFnRaw:e.expression?e.expression:e,expression:e,expressionTypes:u}}}function c(e){try{u().createElement("div").appendChild(e)}catch(e){return!1}}function d(e){let t=e;if("function"==typeof t&&(t=t()),!t)throw new Error("Error in function Dombee.directive(config). config.bindTo returns null but should return a selector, element, Array of elements or function that returns one of these.");if(Array.isArray(t)){for(let e of t)if(!c(e))throw new Error("Error in function Dombee.directive(config). config.bindTo returns an Array, but with invalid elements. Only DOMElements are allowed. But it has "+e);return t}return"string"==typeof t?u().querySelectorAll(t)||[]:[t]}function l(e){const t={};return Object.keys(n).forEach(o=>{let r=n[o],s=r;"function"==typeof r&&(r=r(n),s=r),null==r&&(s="''"),"string"==typeof r&&e&&(s=`'${r}'`),"object"==typeof r&&e&&(s=JSON.stringify(r)),t[o]=s}),t}function u(){return r.document||document}for(let e of r.globalCache.directives){let t="function"==typeof e?e({state:n,data:l()}):e;t=Object.assign({name:e.name},t);const r=d(t.bindTo);for(let e of r){e.dataset=e.dataset||{};const n=e.dataset.id||o("id_");null==e.dataset.id&&(e.dataset.id=n);let r=t.expressions(e);Array.isArray(r)||(r=[r]);for(let e of r)a(e,0,n,t)}}const f=(e,n,o)=>{const r=t.dependencies[n]||[];for(let e of r){const r=t.bindings[e],i=u().querySelector(`[data-id="${r.elemid}"]`),a=s(r.resultFn,r.expressionTypes);r.onChange&&r.onChange(i,a,{values:l,property:n,value:o,expression:r.expression})}};return Object.keys(n).forEach(e=>{"function"==typeof n[e]&&a(n[e],e),f(n,e,n[e])}),{state:n,values:l(),watch:function(e,t){},cache:t}}return Object.assign(r,{directive:function(e){if(null==e)throw new Error("Dombee.directive(config) failed. The first parameter should be a config object or function, but is null.");if(null==e.onChange&&"object"==typeof e)throw new Error('Dombee.directive(config) failed. Your directive config needs property "onChange" to be initialized successfully.');if("function"!=typeof e.onChange&&"object"==typeof e)throw new Error("Dombee.directive(config) failed. config.onChange must be a function.");if("object"==typeof e&&"string"!=typeof e.expressions&&"function"!=typeof e.expressions&&!Array.isArray(e.expressions))throw new Error("Dombee.directive(config) failed. config.expressions must be an Array or a function that returns an Array or a string. But it is "+typeof e.expressions);if("object"==typeof e&&"string"!=typeof e.bindTo&&"function"!=typeof e.bindTo&&!Array.isArray(e.bindTo))throw new Error("Dombee.directive(config) failed. config.bindTo must be an Array, a String or a function that returns an Array or a string. But it is "+typeof e.bindTo);r.globalCache.directives.push(e)},dependencyEvaluationStrategy:function(e){if(null==e)throw new Error("fn is null but must be a function;");r.dependencyEvaluationStrategy=e},dependencyEvaluationStrategyDefault:e,addExpressionType:function(e,t){if(null==e)throw new Error("addExpressionType(name,fn) failed.  Name is undefined");if(null==t)throw new Error("addExpressionType(name,fn) failed. Function fn is undefined");if(getScope(this).globalCache.expressionTypes[e])throw new Error("addExpressionType(name,fn) failed. Expressiontype "+e+" already exists an can not be overwritten. Please choose another name");r.expressionTypes[e]=t},expressionTypeJs:t,expressionTypeJsTemplateString:n,_id:o(),globalCache:{directives:[],dependencyEvaluationStrategy:e,expressionTypes:{js:t,"js-template-string":n},defaultExpressionTypes:["js","js-template-string"]}}),r}();function s(){r.directive(...arguments)}return s({name:"inputElementCheckboxes",bindTo:'input[data-model][type="checkbox"]',expressions:e=>e.dataset.model,onChange(e,t,{property:n,value:o}){o?e.setAttribute("checked","checked"):e.removeAttribute("checked")}}),s((function(){return{bindTo:'[data-model]:not([type="radio"])',expressions:e=>e.dataset.model,onChange(e,t,{property:n,value:o}){e.value=o}}})),s((function(){return{bindTo:'input[data-model][type="radio"]',expressions:e=>e.dataset.model,onChange(e,t,{property:n,value:o}){e.value==o&&e.setAttribute("checked","checked")}}})),s((function(){return{bindTo:"[data-bind]",expressions:e=>e.dataset.bind,onChange(e,t,n){e.innerHTML=t}}})),s((function(){return{expressions:e=>e.dataset.class,bindTo:"[data-class]",onChange(e,t,n){"object"==typeof t?Object.keys(t).forEach(n=>{t[n]?e.classList.add(n):e.classList.remove(n)}):e.setAttribute("class",t)}}})),s((function(){return{bindTo:"[data-style]",expressions:e=>e.dataset.style,onChange(e,t,n){"object"==typeof t?Object.keys(t).forEach(n=>{e.style[n]=t[n]}):e.setAttribute("style",t)}}})),s((function(){return{bindTo:()=>Array.from(document.querySelectorAll("*")).filter(e=>Object.keys(e.dataset).filter(e=>e.startsWith("style.")).length>0),expressions:e=>Object.keys(e.dataset).filter(e=>e.startsWith("style.")).map(t=>e.dataset[t]),onChange(e,t,{property:n}){e.style[n]=t}}})),s((function(){return{bindTo:Array.from(document.querySelectorAll("*")).filter(e=>Object.keys(e.dataset).filter(e=>e.startsWith("class.")).length>0),expressions:e=>Object.keys(e.dataset).filter(e=>e.startsWith("class.")).map(t=>({computation:e.dataset[t],classname:t.replace("class.","")})),onChange(e,t,{property:n,value:o,computation:r}){t?e.classList.add(r.classname):e.classList.remove(r.classname)}}})),s((function({data:e,state:t}){const n=document.querySelectorAll('[data-model]:not([type="checkbox"])'),o=document.querySelectorAll('input[data-model][type="checkbox"]');for(let e of n)e.addEventListener("keyup",(function(){const n=e.dataset.model;t[n]=e.value})),e.addEventListener("change",(function(){const n=e.dataset.model;t[n]=e.value}));for(let e of o)e.addEventListener("change",(function(){const n=e.dataset.model;t[n]=e.checked}))})),s((function(){return{bindTo:"data-show",expressions:e=>e.dataset.show,onChange(e,t){e.style.display=t?"block":"none"}}})),r}();
